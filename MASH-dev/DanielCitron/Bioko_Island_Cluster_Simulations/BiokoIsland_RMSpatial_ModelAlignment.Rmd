---
title: "Spatial Ross-Macdonald Model Applied to Bioko Island"
output: html_document
---

# Human Mobility and Time at Risk in the Bioko Island Metapopulation simulation model

This document will begin by reviewing how we use the Time at Risk (TaR) matrix to model risk and exposure that occurs as a result of human mobility (outlined in RMSpatial.Rmd and TaR.Rmd documents).  We will then show an illustrative example of how to parameterize a MASH-MACRO simulation model of Bioko Island using the MIS data (outlined at: https://github.com/smitdave/MASH-Main/blob/master/MASH-dev/DanielCitron/Bioko_Island_Cluster_Simulations/Bioko_Island_Simulation_Setup.R and based on Ruktanonchai et al. PLoS CB 2016).

## Time at Risk matrix for metapopulation Ross-Macdonald model

We begin by adapting the conventional single-compartment Ross-Macdonald (RM) model by including multiple compartments. Each compartment represents a "patch" or geographical region where humans live. Interactions between patches are modeled by allowing humans from one patch to spend some time in another patch, as denoted by the Time at Risk (TaR) matrix.  The TaR matrix $\psi$ is defined such that element $\psi_{i,j}$ is the fraction of time that a human who lives at site $i$ spends at site $j$.  That is to say, $\psi_{i,j}$ is the fraction of _risk of exposure_ that each person living at site $i$ experiences because of time spent visitng site $j$.

The multi-compartmental RM model can be rewritten as follows using $\vec{X}$ to represent the vector of infectious humans, such that $X_i$ is the number of infectious humans in the $i$th compartment. $\vec{H}$ is the vector of total human population in each compartment.  $(\vec{M}, \vec{Y}, \vec{Z})$ are vectors representing the total population of mosquitoes, the population of infected mosquitoes, and the population of infectious mosquitoes, respectively, each compartment.

$$
\begin{split}
  & \frac{d X_i}{dt} = \left( \psi \cdot \vec{h}_{(\psi)} \right)_i \times \left(H_i - X_i\right) - r X_i \\
  & \frac{d Y_i}{dt} = a_i c_i \kappa_i \left( M_i - Y_i \right) - g_i Y_i \\
\end{split}
$$
In addition to the standard parameter sets (vectorized across each patch) $(\vec{a}, \vec{b}, \vec{c}, \vec{g}, r)$, there are two additional terms that need to be defined.  The first $\vec{\kappa}$ is the rate at which infectious humans transfer parasite to mosquitoes that bite them, and is defined such that includes the force of infection due to humans from patch $j$ visiting patch $i$:

$$
\kappa_i \equiv \frac{\sum_j \psi_{j,i} X_j}{\sum_j \psi_{j,i} H_j} = \frac{\left( \psi^T \cdot \vec{X}\right)_i}{\left( \psi^T \cdot \vec{H}\right)_i}
$$
The second term $\vec{h}_{(\psi)}$ represents the force of infection (roughly, "happenings" or EIR) on humans, properly normalized to account for the fact that humans are moving around and visiting different patches:

$$
 \left(\vec{h}_{(\psi)}\right)_i \equiv a_i b_i \frac{Z_i}{\left(\vec{H}_{(\psi)}\right)_i} = a_i b_i \frac{Z_i}{\left( \psi^T \cdot \vec{H}\right)_i}
$$
Assuming dynamical equilibrium, we may add a third equation which allows us to solve the RM model:
$$
Z_i = Y_i e^{-g_i n_i}
$$

For the purposes of mapping risk and importation, we choose to remain agnostic about the exact functional forms of how the population density of infectious mosquitoes maps onto the force of infection.  Instead, our plan is to leverage malaria prevalence data to parameterize $\vec{X}$ and travel survey data to parameterize $\psi$ in order to _solve for the force of infection_ $\vec{E}_{(\psi)}$ _for all of the patches included in the model_.  At equilibrium, the model becomes:
$$
\begin{split}
  & 0 =  \left( \psi \cdot \vec{h}_{(\psi)} \right)_i \times \left(H_i - X_i\right) - r X_i \\
  & \frac{r X_i}{H_i - X_i} = \left( \psi \cdot \vec{h}_{(\psi)} \right)_i \\
  & \Rightarrow \left(\vec{h}_{(\psi)}\right)_i = \sum_i \left(\psi^{-1}\right)_{ij} \cdot \frac{r x_i}{1 - x_i} \\
\end{split}
$$
where $\vec{x}$ is defined as the prevalence (fraction) in each patch ($x_i \equiv X_i/H_i$)

In addition, we will also include treatment seeking behavior in the model, such that some humans end up with symptoms that prompt them to seek treatment.   We may accordingly parameterize our model, where the probability that a human seeks treatment is $\rho \equiv \mathbb{P}(treatment \mid fever)\mathbb{P}(fever)$.  We adapt the model by allowing some humans to move to a "protected" status following infection, and the resulting expression for the unknown force of infection becomes:
$$ 
\left(\vec{h}_{(\psi)}\right)_i = \sum_i \left(\psi^{-1}\right)_{ij} \cdot \left(\frac{r}{1 - \rho} \frac{x_i}{\left(1 - (1 + \frac{\rho}{\epsilon}\frac{r}{1-\rho} ) x_i \right)}\right)
$$

## Calibrating MASH-MACRO using data from the Bioko Island Malaria Elimination Program

We now apply this formalism to the case of Bioko Island, where surveys have made it possible to estimate the PfPR ($\vec{x}$) across the island.  Additionally, the surveys also say how frequently people from each area on Bioko Island travel to different destinations both on and off the island.  We can use this second data set to fit a travel model to estimate the TaR matrix $\psi$.

The Bioko Island data set consists of 194 populated patches representing a 1x1 square kilometer region.  The total island population consists 226,000 people, with the majority of the population living in and around the capitol city (Malabo) at the north of the island.

The data related to travel include two survey questions, one related to destinations of travel (which places did you travel to in the past 8 weeks) and one related to frequency of travel (how many times did you travel in the past 6 months). For the travel destinations, respondents reported that they traveled to one of seven destinations, each representing a settlement or geographical region: Malabo (the capitol city), Baney (northeast), Luba (west), Moka (south), Riaba (east),  Ureka (far south), and "off-island".  Here we will assume that all off-island travelers visited mainland Equatorial Guinea, although it is possible that they visited other places.  The travel survey data are aggregated over three years, from 2015-2017.  We will then fit these data to a travel model in order to estimate the frequency of travel between each patch and each destination. 

We note that the travel origins within the island are 1x1 square kilometer patches, but the within-island travel destinations represent large regions that represent agglomerations of many patches. This is important to keep in mind because in the future we may need to find a way to disambiguate, for example, "traveling to the region of Malabo" from "traveling to a specific patch within the Malabo region."  For now, however, we will stick to using each patch on the island as a travel origin and 7 regions as destinations.  We will agglomerate the total population of each region, as well as compute averages of quantities like PfPR over all patches within each region.

The resulting travel matrix can be broken down like this:

![TaR matrix schematic](TaR_schematic.jpg)

__Note__: The one important piece that is missing is an additional time scale that defines _how long_ on average a given traveler spends away from home.  The travel destinations inform where each traveler tends to go.  The travel frequency data inform how often a traveler leaves home.  But importantly the TaR matrix counts the fraction of time spent in each location, not the frequency at which travelers arrive there.  We will need to make some additional assumptions about time spent away from home in order to convert from the _travel frequency_ to the _time spent at risk_.

```{r}
library(data.table, quietly = TRUE) # The workhorse of this exercise
library(pscl, quietly = TRUE) # Used for fitting the travel model 
library(boot, quietly = TRUE)
library(MASS, quietly = TRUE)
```



### 1. Read in all data

#### Total population denominator
```{r}
denom <- data.table(read.csv("BI_sim_setup_data/bioko_areas.csv"))
```

#### We use the mean PfPR estimates from Su's prevalence map, initially produced in October of 2017.
```{r}
pfpr <- data.table(read.csv("BI_sim_setup_data/data_area.csv"))
```

#### Travel survey data, aggregated by Carlos
```{r}
travel <- data.table(read.csv("BI_sim_setup_data/summaries.csv"))
```

#### Travel times between all areas, estimated using MAP's friction surfaces
```{r}
times <- data.table(read.csv("BI_sim_setup_data/travel_times.csv"))
# rename some of the columns, and reorder
times <- times[, 5:199]
colnames(times)[2:195] <- sapply(colnames(times)[2:195], FUN = function(s){
  return(substring(s, 2, 5))}
)
setcolorder(times, c(1,order(as.integer(colnames(times)[2:195]))+1))
times <- times[order(areaId)]
```




### 2. Merge and combine relevant data
For each area, we need to know the number of times that the survey respondents from each patch traveled to each possible travel destination.  Combine the data into a single table, and extract the subset that is relevant to what we need.  The last bloc of columns in the table represent counts of number of times people have traveled to each of the seven destination regions:

  * `to` = traveling off-island
  * `ti_ban` = Baney regional travel
  * `ti_mal` = Malabo regional travel
  * `ti_lub` = Luba regional travel
  * `ti_ria` = Riaba regional travel
  * `ti_mok` = Moka regional travel
  * `ti_ure` = Ureka regional travel

```{r}
# Combine travel with pfprsu based on areaId
travel <- merge(travel, pfpr[,.(areaId, pfpr)], by = "areaId")
# Combine geographic data with travel based on areaId
travel<- merge(travel, denom[,c("areaId", "pop", "lon", "lat")], by = "areaId")

# Here's the subset that I'll be dealing with for the travel model
travel.model.data <- travel[, .(areaId, lon, lat, X, Y, # areaID and location
                                # A2 region and whether or not the patch is near Malabo
                                ad2, malabo, 
                                # Population, PfPR
                                pop, pfpr, 
                                 # Cluster ID
                                clusId,
                                # Number surveyed, number surveyed with Pf+
                                n, pf,
                                # Number surveyed who reported fever, got treatment
                                pffv, pftto, 
                                # Number of times traveled to each destination, 2015-2017
                                to, ti_ban, ti_mal, ti_lub, ti_ria, ti_mok, ti_ure 
)]
```


### 3. Travel times
We use the time of travel as a proxy for geographical distance when fitting our model because the geography of Bioko Island restricts movement in straight lines across the island.  We calculate the travel time between each patch and each destination region by averaging over the travel times to each patch in the destination region. We either perform a simple average, or an average weighted according to resident population in each target patch (the two ways of averaging do not produce dramatically different results).

```{r}
all = travel.model.data[, .(areaId, ad2, pop)]
all.times = merge(all, times, by = "areaId", all = FALSE)
# Names of the target regions
admin2.names = levels(unique(travel.model.data$ad2))
# Names of target regions, "tt" = "time to" 
tt.weighted.names = c("tt.weighted.ban", "tt.weighted.lub", "tt.weighted.mal",
                      "tt.weighted.mok", "tt.weighted.ria", "tt.weighted.ure")
tt.sum.names = c("tt.sum.ban", "tt.sum.lub", "tt.sum.mal",
                 "tt.sum.mok", "tt.sum.ria", "tt.sum.ure")
# Loop over target regions
for(i in c(1:length(admin2.names))){
  # Time to all patches in the target region
  reg.times <- all.times[ad2==admin2.names[[i]]][, !c("areaId", "ad2", "pop" )]
  # The weighted average of travel times to the malabo area from each patch
  reg.times1 <- data.table(
    all.times[ad2 == admin2.names[[i]] ]$pop %*% as.matrix(
      reg.times, 
      ncol = ncol(reg.times), 
      nrow = nrow(all.times[ad2 == admin2.names[[i]] ])
      )/sum(all.times[ad2 == admin2.names[[i]] ]$pop)
    )
  reg.times1 <- melt(reg.times1,
                     measure.vars = colnames(reg.times1), 
                     variable.name = "areaId", 
                     value.name = tt.weighted.names[[i]])
  reg.times1$areaId <- as.integer(levels(reg.times1$areaId))
  # The unweighted average of travel times to the malabo area from each patch
  reg.times2 <- data.table(
    matrix(
      colSums(as.matrix(
        reg.times, 
        ncol = ncol(mal.times), 
        nrow = nrow(all.times[ad2 == admin2.names[[i]] ]))
        )/nrow(all.times[ad2 == admin2.names[[i]] ]), nrow = 1)
    )
  reg.times2 <- melt(reg.times2, 
                     measure.vars = colnames(reg.times2), 
                     variable.name = "areaId", 
                     value.name = tt.sum.names[[i]] )
  reg.times2$areaId = reg.times1$areaId
  # Add to data set
  # Average time to travel to each of the regions
  travel.model.data <- merge(travel.model.data, reg.times1, by = "areaId", all = FALSE)
  travel.model.data <- merge(travel.model.data, reg.times2, by = "areaId", all = FALSE)
}
```

We estimate the travel time to mainland by assuming that first people travel to Malabo and then take a plane off-island. The time to travel to the mainland by plane is 45 minutes, so we add 3x45 minutes extra travel time to reach the mainland from Malabo.
```{r}
# Use: time to travel to mainland = time to travel to malabo + 45*3 minutes
# where 45 minutes is the time of the flight
# Use: time to travel to mainland = time to travel to malabo + 8 hours
# where 8 hours is the time on the boat
# Using boat travel time does appear to give a better AIC for our modeling fits
travel.model.data$tt.weighted.o = travel.model.data$tt.weighted.mal + 8*60 #135
travel.model.data$tt.sum.o = travel.model.data$tt.sum.mal + 8*60 #135
```


#### 4. Fit the data to a travel model

First, we reformat our data to be easier to plug into our travel model.  The off-island population is taken from CIA world factbook for the whole of EG minus the BI total population.
```{r}
reg.names = c("to", "ti_ban", "ti_lub", "ti_mal", "ti_mok", "ti_ria", "ti_ure")
tt.s.names = c("tt.sum.o", tt.sum.names)
tt.w.names = c("tt.weighted.o",tt.weighted.names)
travel.model.data <- melt(travel.model.data,
                          id.vars = setdiff(colnames(travel.model.data), 
                                            union(union(tt.w.names, tt.s.names), 
                                                  reg.names)),
                          measure.vars = list(reg.names, tt.w.names, tt.s.names),
                          variable.name = "Region", 
                          value.name = c("Freq", "TravelTime.Weighted", "TravelTime.Sum"),
                          value.factor = TRUE)
# Set NA travel frequencies to 0:
travel.model.data[is.na(Freq)]$Freq <- 0

# Write in the population of each target region
reg.pops = c(552408, 
             sum(travel.model.data[ad2 == "Baney"]$pop)/7,
             sum(travel.model.data[ad2 == "Luba"]$pop)/7,
             sum(travel.model.data[ad2 == "Malabo"]$pop)/7,
             sum(travel.model.data[ad2 == "Moka"]$pop)/7,
             sum(travel.model.data[ad2 == "Riaba"]$pop)/7,
             sum(travel.model.data[ad2 == "Ureka"]$pop)/7)
travel.model.data$pop.Region = 0
travel.model.data$pop.Region <- sapply(travel.model.data$Region, 
                                       FUN = function(s){return(reg.pops[[s]])})
# Rename the "Regions," mapping from numbers to location names
reg.names = c("off", "baney", "luba", "malabo", "moka", "riaba", "ureka")
travel.model.data$TravelRegion <- sapply(travel.model.data$Region, 
                                         FUN = function(s){return(reg.names[[s]])})

# And just in case, remove all of the zeroes from the travel times:
travel.model.data[TravelTime.Weighted < 1]$TravelTime.Weighted <- 1
travel.model.data[TravelTime.Sum < 1]$TravelTime.Sum <- 1
```

Our model is going to estimate the number of trips taken from each area on BI to each of 7 travel destinations *in the surveyed population sample*.  This is questionable, given that the population sample size varies across the island, but until we can build a more nuanced model this is where we will settle for now.
```{r}
# Replace all of the n=NA with 0
travel.model.data[is.na(n)]$n <- 1
```



We now fit the data to the travel model.  The travel model is a statistical model that estimates the number of times a person travels from one patch to one destination based on the distance (travel time) separating the two locations and the respective populations in each location.  We expect that the travel frequency should increase with the population of the origin and destination region and decrease with travel time.
$$
Freq \sim \log(\text{population}_\text{origin}) + \log(\text{population}_\text{destination region}) + \text{time}_\text{separation}
$$
We use a zero inflated negative binomial regression to fit our model.  In order to remain consistent with the assumptions that go into the model (Gaussian-distributed input variables), we log-transform each of the population data sets.
```{r}
# Log transform population data
travel.model.data$pop.log = log(travel.model.data$pop)
travel.model.data$pop.Region.log = log(travel.model.data$pop.Region)
# Here we use the weighted average travel times
# but the unweighted average could also be used and the answers are not too different


# non-log-transformed travel times
gravity.zinb.log.w <- zeroinfl(Freq ~ pop.log + pop.Region.log + TravelTime.Weighted, 
                               data = travel.model.data, dist = "negbin")

gravity.zinb.log.s <- zeroinfl(Freq ~ pop.log + pop.Region.log + TravelTime.Sum, 
                               data = travel.model.data, dist = "negbin")
```

We can now use the model to "predict" what the frequency of travel is between each origin patch and each destination location
```{r}
travel.model.data$predict.zinb.log.w <- predict(gravity.zinb.log.w, 
                                                data = travel.model.data, 
                                                type = "response")

travel.model.data$predict.zinb.log.s <- predict(gravity.zinb.log.s, 
                                                data = travel.model.data, 
                                                type = "response")
```

__Note__: We probably want to establish some standards for evaluating goodness of fit.  Using the zero-inflated negative binomial model to fit the travel model was determined using Vuong's non-nested hypothesis test, which compares two models to one another.  But in the future we will want to also be able to quantitatively compare our data and our model's prediction.

Show AIC for the two fit models
```{r}
# AIC for our model prediction, with weighted travel times:
AIC(gravity.zinb.log.w)
# AIC for our model prediction, with summed travel times:
AIC(gravity.zinb.log.s)
```

Some more statistical fits, comparing different models.  Include non-transformed populations, non-transformed travel times, zero-inflated poisson fits, negative binomial fits, poisson fits.  (This is not yet a comprehensive overview of all possible fits we can perform, but we can make it comprehensive if we want.)  Overall, the zero-inflated negative binomial model with log-transformed populations seems to have the smallest AIC value.
```{r}
# non-log-transformed populations
holder <- zeroinfl(Freq ~ pop + pop.Region + TravelTime.Weighted, 
                   data = travel.model.data, dist = "negbin")
AIC(holder)

# log-transformed travel times
holder <- zeroinfl(Freq ~ pop.log + pop.Region.log + log(TravelTime.Weighted), 
                   data = travel.model.data, dist = "negbin")
AIC(holder)

# zero-inflated poisson fit
holder <- zeroinfl(Freq ~ pop.log + pop.Region.log + TravelTime.Weighted, 
                               data = travel.model.data, dist = "poisson")
AIC(holder)

# ordinary negative binomial fit
holder <- glm.nb(Freq ~ pop.log + pop.Region.log + TravelTime.Weighted,
                 data = travel.model.data)
AIC(holder)

# ordinary negative binomial fit, without log transformed variables
holder <- glm.nb(Freq ~ pop + pop.Region + TravelTime.Weighted,
                 data = travel.model.data)
AIC(holder)

# ordinary poisson fit
holder <- glm(Freq ~ pop.log + pop.Region.log + TravelTime.Weighted, family = "poisson", 
              data = travel.model.data)
AIC(holder)
```


#### 5. Calculate probability of fever and seeking treatment
```{r}
h <- travel.model.data[pf > 0][, c("pf", "pffv", "pftto")]
fever.pf = sum(h$pffv)/sum(h$pf)
# binom.test(x = c(sum(h$pffv), sum(h$pf - h$pffv)))
treat.pf = sum(h[pffv >0]$pftto)/sum(h[pffv >0]$pffv)
# binom.test(x = c(sum(h[pffv >0]$pftto),
#            sum(h[pffv >0]$pffv) - sum(h[pffv >0]$pftto) )) # 0.6025641
```


#### 6. Construct the TaR matrix
```{r}
# In order to keep track of each patch, we need to index on areaID
areaIds <- sort(unique(travel.model.data$areaId))
```

Construct the vector of denominator populations ($\vec{H}$) for each patch and each destination region.
```{r}
human.pops = rep(0, 194+7)
# Island patches
for (i in 1:194){
  human.pops[i] <- travel.model.data[areaId == areaIds[i] & Region == 1]$pop
}
human.pops[(194 + 1) : (194 + 7)] <- reg.pops
```

Construct the vector of PfPR ($\vec{x}$) for each patch and each destination region using a weighted sum.
```{r}
pfpr.input = rep(0, 194 + 7)
# Island patches
for (i in 1:194){
  pfpr.input[i] <- travel.model.data[areaId == areaIds[i] & Region == 1]$pfpr
}
# "Off-island"
pfpr.input[194 + 1] <- 0.5
# Baney
pfpr.input[194 + 2] <- (travel.model.data[ad2 == "Baney"]$pop %*% 
                       travel.model.data[ad2 == "Baney"]$pfpr / 
                       sum(travel.model.data[ad2 == "Baney"]$pop))[[1]]
# Luba
pfpr.input[194 + 3] <- (travel.model.data[ad2 == "Luba"]$pop %*% 
                       travel.model.data[ad2 == "Luba"]$pfpr / 
                       sum(travel.model.data[ad2 == "Luba"]$pop))[[1]]
# Malabo
pfpr.input[194 + 4] <- (travel.model.data[ad2 == "Malabo"]$pop %*% 
                       travel.model.data[ad2 == "Malabo"]$pfpr / 
                       sum(travel.model.data[ad2 == "Malabo"]$pop))[[1]]
# Moka
pfpr.input[194 + 5] <- (travel.model.data[ad2 == "Moka"]$pop %*% 
                       travel.model.data[ad2 == "Moka"]$pfpr / 
                       sum(travel.model.data[ad2 == "Moka"]$pop))[[1]]
# Riaba
pfpr.input[194 + 6] <- (travel.model.data[ad2 == "Riaba"]$pop %*% 
                       travel.model.data[ad2 == "Riaba"]$pfpr / 
                       sum(travel.model.data[ad2 == "Riaba"]$pop))[[1]]
# Ureka
pfpr.input[194 + 7] <- (travel.model.data[ad2 == "Ureka"]$pop %*% 
                       travel.model.data[ad2 == "Ureka"]$pfpr / 
                       sum(travel.model.data[ad2 == "Ureka"]$pop))[[1]]
```

As noted above, one key parameter that is missing from our data is a time scale that allows us to determine the fraction of time spent away from home, as opposed to how frequently each person travels to each destination region.  We will assume that each on-island trip lasts about 3 days, and each off-island trip lasts about 7 days.
```{r}
# Most of the elements of this matrix are empty:
# Only where i is a patch and j is a region do we have nonzero entries
P.ij <- diag(1, nrow = 194+7, ncol = 194+7)
for (i in 1:194){
  holder = rep(0, 7)
  for (j in 1:7){
    # Total number of trips, for all people
    holder[j] <- travel.model.data[areaId == areaIds[i] & TravelRegion == reg.names[j]]$predict.zinb.log.w
  }
  # Average number of trips each person makes - Divide out by the number of people in each area's population sample (n)
  d <- travel.model.data[areaId==areaIds[i]]$n
  holder <- holder/d
  # Fraction of time spent in each location by each person
  # Note that the time spent on the mainland 
  holder <-  holder*52/(8)*c(7,3,3,3,3,3,3)/365
  #holder <-  c(7,3,3,3,3,3,3)/365*holder
  # Time spent away
  P.ij[i, (194 + 1):(194+7)] <- holder
  # Time spent at home
  P.ij[i, i] <- 1 - sum(holder)
}

# Saving output:
# This was calculated by fitting a model where we rescaled the travel frequency from the sample size to the full population size
#colnames(P.ij) <- c(as.character(areaIds), "OffIsland", "Baney", "Luba", "Malabo", "Moka", "Riaba", "Ureka")
#rownames(P.ij) <- c(as.character(areaIds), "OffIsland", "Baney", "Luba", "Malabo", "Moka", "Riaba", "Ureka")
#write.csv(x = P.ij, file = "/Users/dtcitron/Documents/MASH/Bioko_Macro/FOI_Maps_With_TaR/TaR_matrix.csv")
```

What we find is that most people spend about 95-100% of their time at home
```{r}
hist(diag(P.ij[1:194, 1:194]))

# Notice that there are quite a few outliers here - all of these represent patches where very few people live
# This seems wrong
# These are the areas where we have too much travel!  They are all tiny!
areaIds[which(rowSums(P.ij[1:194, 195:201]) > .15)]
travel.model.data[areaId == 573]

travel.model.data[areaId == 573]$predict.zinb.log.w/travel.model.data[areaId == 573]$n*52/(8)*c(7,3,3,3,3,3,3)/365

```


#### 7. Solving for force of infection using TaR matrix
Define parameters.  In the most general version of the multi-patch RM model many of these parameters are allowed to vary across patches, but here we will assume they are constant.  (Not all parameters are used in the TaR calculation here.)
```{r}
# Assemble the parameters!
a = 0.3*0.9
b = 0.55
c = 0.15
rho = fever.pf*treat.pf
r = 1./200 # rate at which people become cured
eta = 1./30 # rate at which prophylaxis wears off
p = 0.9 # fraction of surviving mosquitoes
g = 1 - p # fraction of dying mosquitoes
peip = p^11 # fraction of mosquitoes who survive incubation period
```

Recalling:
$$
\left(\vec{h}_{(\psi)}\right)_i = \sum_i \left(\psi^{-1}\right)_{ij} \cdot \left(\frac{r}{1 - \rho} \frac{x_i}{\left(1 - (1 + \frac{\rho}{\epsilon}\frac{r}{1-\rho} ) x_i \right)}\right)
$$

```{r}
g <- r/(1-rho)*pfpr.input/(1-(1+rho*r/eta/(1-rho))*pfpr.input)
FOI <- ginv(P.ij) %*% g
# merge with travel.model.data
travel.model.data[, foi:=NULL]
travel.model.data <- merge(travel.model.data, data.table(areaId = areaIds, foi = FOI[1:194]), by = "areaId")

# And for plotting, we can set the negative regions to have 0 local FOI
travel.model.data[, foi.plot:=NULL]
FOI.plot = FOI
FOI.plot[which(FOI.plot < 0)] <- 0
travel.model.data <- merge(travel.model.data, data.table(areaId = areaIds, foi.plot = FOI.plot[1:194]), by = "areaId")
```

__Sanity Check__: One important constraint on the solution here is that the FOI must be non-negative.

One problem here is that apparently there's a lot of smoothing going on - it's not clear whether this is because of the travel model or not?
It could be that because there's higher PfPR in Malabo, but also more travel in Malabo, we also have decreased local EIR in Malabo - the residents of that district have increased total risk because of the time spent on the island?
At the same time, the time spent traveling is a tiny fraction of the total time - so why should we expect the travel matrix to have any noticeable effect at all?

### Visualizations
```{r, include = FALSE}
library(ggplot2, quietly = TRUE)
library(sp, quietly = TRUE)
library(maptools, quietly = TRUE)
library(rgdal, quietly = TRUE)
library(rgeos, quietly = TRUE)
library(gpclib, quietly = TRUE)

# Read in shape files of Bioko Island and the area-level grid
bioko<-readOGR("BI_maps/bioko", "bioko_admin1")
areas_inh<-readOGR("BI_maps/areas_inh", "areas_inh")
areasf<-fortify(areas_inh, region = "areaId")
# Merge travel.model.data with the area-level grid shapefile
area.data = merge(areasf, travel.model.data, by.x = "id", by.y = "areaId", all=TRUE)
plot.data<-area.data[order(area.data$order), ]
```


Plot the mean surface of MAP's PfPR estimates, showing a range from 5 to 45%.  The dark gray areas have very low estimated PfPR.
```{r fig.width=6, fig.height=6, echo = FALSE}
# PfPR map
p1 = ggplot(data = plot.data, aes(x=long, y=lat.x, group = group))
p2 = p1 + geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill="grey", size = 0.25)
pr <- p2 + geom_polygon(data = plot.data, aes(x = long, y = lat.x, group = group, fill = pfpr*100), color = NA, size = 0.25) +
  scale_fill_gradient(name="PfPR (%)", low="yellow", high="red", limits=c(5,45)) +
  geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill=NA, size = 0.25) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(), panel.background=element_blank(), legend.position=c(0.2, 0.8))
pr
```

Plot the annual FOI.  The dark gray areas have negative FOI, meaning that there is too much travel estimated for those areas.  Note also that areas with negative FOI also have very low estimated PfPR.
```{r fig.width=6, fig.height=6, echo = FALSE}
# EIR map
p1 = ggplot(data = plot.data, aes(x=long, y=lat.x, group = group))
p2 = p1 + geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill="grey", size = 0.25)
eir <- p2 + geom_polygon(data = plot.data, aes(x = long, y = lat.x, group = group, fill = foi*365), color = NA, size = 0.25) +
  scale_fill_gradient(name="FOI (Annual EIR)", low="yellow", high="red", limits=c(0,1.5)) +
  geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill=NA, size = 0.25) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(), panel.background=element_blank(), legend.position=c(0.2, 0.8))
eir
```


How does this FOI map differ from what we would find if there were no travel at all?
```{r}
g <- r/(1-rho)*pfpr.input/(1-(1+rho*r/eta/(1-rho))*pfpr.input)
FOI.notravel <- g
# merge with travel.model.data
travel.model.data[, foi.nt:=NULL]
travel.model.data <- merge(travel.model.data, data.table(areaId = areaIds, foi.nt = FOI.notravel[1:194]), by = "areaId")

# Merge travel.model.data with the area-level grid shapefile
area.data = merge(areasf, travel.model.data, by.x = "id", by.y = "areaId", all=TRUE)
plot.data<-area.data[order(area.data$order), ]
```

```{r fig.width=6, fig.height=6, echo = FALSE}
# EIR map
p1 = ggplot(data = plot.data, aes(x=long, y=lat.x, group = group))
p2 = p1 + geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill="grey", size = 0.25)
eir.notravel <- p2 + geom_polygon(data = plot.data, aes(x = long, y = lat.x, group = group, fill = foi.nt*365), color = NA, size = 0.25) +
  scale_fill_gradient(name="FOI (Annual EIR), No Travel", low="yellow", high="red", limits=c(0,1.5)) +
  geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill=NA, size = 0.25) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(), panel.background=element_blank(), legend.position=c(0.2, 0.8))
eir.notravel
```



Plotting the percent change in FOI adding travel.  Note that there are no areas with positive change to FOI following the addition of travel to the model - only areas where the addition of travel cause the local estimate of FOI decrease - by as much as -400% in some places.
```{r fig.width=6, fig.height=6, echo = FALSE}
p1 = ggplot(data = plot.data, aes(x=long, y=lat.x, group = group))
p2 = p1 + geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill="grey", size = 0.25)
eir.notravel <- p2 + geom_polygon(data = plot.data, aes(x = long, y = lat.x, group = group, fill = 100*(foi - foi.nt)/foi.nt), color = NA, size = 0.25) +
  scale_fill_gradient(name="% change in FOI, with travel", low="yellow", high="red", limits=c(-50,0)) +
  geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill=NA, size = 0.25) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(), axis.title.y=element_blank(), 
        panel.background=element_blank(), legend.position=c(0.2, 0.8))
eir.notravel
```

Examine the PfPR and FOI in Moka, the 5 areas grouped in the middle of the southwestern part of Riaba district.  How much travel is reported in this area?  How much travel is estimated in this area?
```{r}
moka.travel.data <- travel.model.data[ad2 == "Moka"]
moka.areaIds <- unique(moka.travel.data$areaId)

# Which indices correspond to this subset of areas?
moka.ix <- which(areaIds %in% moka.areaIds)
moka.pfpr.input <- pfpr.input[c(moka.ix, (194+1):(194+7))]

# Can I create a TaR matrix just for this one set of areas?


P.ij.moka <- diag(1, nrow = 5+7, ncol = 5+7)
for (i in 1:5){
  holder = rep(0, 7)
  for (j in 1:7){
    # Total number of trips, for all people
    holder[j] <- moka.travel.data[areaId == moka.areaIds[i] & TravelRegion == reg.names[j]]$predict.zinb.log.w
  }
  # Average number of trips each person makes - Divide out by the number of people in each patch
  d <- moka.travel.data[areaId==moka.areaIds[i]]$pop
  holder <- holder/d
  # Fraction of time spent in each location by each person
  # Note that the time spent on the mainland 
  holder <-  c(7,3,3,3,3,3,3)*52/(8)/365*holder
  #holder <-  c(7,3,3,3,3,3,3)/365*holder
  # Time spent away
  P.ij.moka[i, (5 + 1):(5+7)] <- holder
  # Time spent at home
  P.ij.moka[i, i] <- 1 - sum(holder)
}
# Can show: this is just a subset of P.ij, with the appropriate row/column indices examined
#moka.ix <- which(areaIds %in% moka.areaIds)
#P.ij[moka.ix,moka.ix]


g.moka <- r/(1-rho)*moka.pfpr.input/(1-(1+rho*r/eta/(1-rho))*moka.pfpr.input)
FOI.moka <- ginv(P.ij.moka) %*% g.moka
FOI.moka

# What happens when we force the negative FOI areas to zero?  What kind of local pfpr do we find?

FOI.moka[which(FOI.moka < 0)] <- 0
g.inv <- P.ij.moka %*% FOI.moka

cbind(g.inv/( g.inv*(1+rho*r/eta/(1-rho)) + r/(1-rho)), moka.pfpr.input)

moka.pfpr.input

g.moka
```


```{r fig.width=6, fig.height=6, echo = FALSE}
# EIR map
p1 = ggplot(data = plot.data, aes(x=long, y=lat.x, group = group))
p2 = p1 + geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill="grey", size = 0.25)
eir.plot <- p2 + geom_polygon(data = plot.data, aes(x = long, y = lat.x, group = group, fill = foi.plot*365/.55), color = NA, size = 0.25) +
  scale_fill_gradient(name="Annual EIR", low="yellow", high="red", limits=c(0,3)) +
  geom_polygon(data = bioko, aes(x = long, y = lat, group = group), color = "black", fill=NA, size = 0.25) +
  theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(), panel.background=element_blank(), legend.position=c(0.2, 0.8))
eir.plot
```

We also should try visualizing the rates of travel to the different locations on the island. Start by using a 

  * Columns should include areaId, population, pfpr, A2 district, and 7 columns of the number of days spent in each location

```{r}
travel.rates <- travel[, .(areaId, # areaID
                          # A2 region and whether or not the patch is near Malabo
                          ad2, malabo, 
                          # Population, PfPR
                          pop, pfpr 
                          # 
                      )]
# The row indices of each areaId should be the same as in areaIds
# Scale up to show time spent per year
travel.rates$t.off <- P.ij[1:194,(194 + 1)]*365 
travel.rates$t.ban <- P.ij[1:194,(194 + 2)]*365
travel.rates$t.lub <- P.ij[1:194,(194 + 3)]*365
travel.rates$t.mal <- P.ij[1:194,(194 + 4)]*365
travel.rates$t.mok <- P.ij[1:194,(194 + 5)]*365
travel.rates$t.ria <- P.ij[1:194,(194 + 6)]*365
travel.rates$t.ure <- P.ij[1:194,(194 + 7)]*365
```

Now let's see if the average time spent in malabo vs. off-island vs. rest-of-island reflects the same patterns reported by Carlos
```{r}
# Travel from Malabo off-island, in person-days over the course of a year
travel.rates[ad2 == "Malabo",]$t.off %*% travel.rates[ad2 == "Malabo",]$pop/sum(travel.rates[ad2 == "Malabo",]$pop)
# Travel from Malabo to rest of island
(travel.rates[ad2 == "Malabo",]$t.ban + travel.rates[ad2 == "Malabo",]$t.lub + 
    travel.rates[ad2 == "Malabo",]$t.mok + travel.rates[ad2 == "Malabo",]$t.ure) %*% travel.rates[ad2 == "Malabo",]$pop/sum(travel.rates[ad2 == "Malabo",]$pop)
# Travel from Malabo to Malabo
travel.rates[ad2 == "Malabo",]$t.mal %*% travel.rates[ad2 == "Malabo",]$pop/sum(travel.rates[ad2 == "Malabo",]$pop)

# Repeat, but with Urban Malabo instead of ad2 malabo
# Travel from Malabo off-island, in person-days over the course of a year
travel.rates[malabo == "Malabo",]$t.off %*% travel.rates[malabo == "Malabo",]$pop/sum(travel.rates[malabo == "Malabo",]$pop)
# Travel from Malabo to rest of island
(travel.rates[malabo == "Malabo",]$t.ban + travel.rates[malabo == "Malabo",]$t.lub + 
    travel.rates[malabo == "Malabo",]$t.mok + travel.rates[malabo == "Malabo",]$t.ure) %*% travel.rates[malabo == "Malabo",]$pop/sum(travel.rates[malabo == "Malabo",]$pop)
# Travel from Malabo to Malabo
travel.rates[malabo == "Malabo",]$t.mal %*% travel.rates[malabo == "Malabo",]$pop/sum(travel.rates[malabo == "Malabo",]$pop)

# Now compare this to the rest of the island
ori <- "Riaba" # "Luba", "Moka", "Ureka"
# Travel from rest of island off-island
travel.rates[ad2 == ori,]$t.off %*% travel.rates[ad2 == ori,]$pop/sum(travel.rates[ad2 == ori,]$pop)
# Travel from rest of island  to rest of island
(travel.rates[ad2 == ori,]$t.ban + travel.rates[ad2 == ori,]$t.lub + 
    travel.rates[ad2 == ori,]$t.mok + travel.rates[ad2 == ori,]$t.ure + 
    travel.rates[ad2 == ori,]$t.ria) %*% travel.rates[ad2 == ori,]$pop/sum(travel.rates[ad2 == ori,]$pop)
# Travel from from rest of island to Malabo
travel.rates[ad2 == ori,]$t.mal %*% travel.rates[ad2 == ori,]$pop/sum(travel.rates[ad2 == ori,]$pop)


# Travel from everywhere outside of Malabo to off-island, in person-days over the course of a year
travel.rates[ad2 != "Malabo",]$t.off %*% travel.rates[ad2 != "Malabo",]$pop/sum(travel.rates[ad2 != "Malabo",]$pop)
# Travel to rest of island
(travel.rates[ad2 != "Malabo",]$t.ban + travel.rates[ad2 != "Malabo",]$t.lub + 
    travel.rates[ad2 != "Malabo",]$t.mok + travel.rates[ad2 != "Malabo",]$t.ure +
    travel.rates[ad2 != "Malabo",]$t.ria) %*% travel.rates[ad2 != "Malabo",]$pop/sum(travel.rates[ad2 != "Malabo",]$pop)
# Travel to Malabo
travel.rates[ad2 != "Malabo",]$t.mal %*% travel.rates[ad2 != "Malabo",]$pop/sum(travel.rates[ad2 != "Malabo",]$pop)


sum(travel.rates[ad2 != "Malabo",]$pop)
sum(travel.rates[ad2 == "Baney",]$pop) + sum(travel.rates[ad2 == "Luba",]$pop) +
  sum(travel.rates[ad2 == "Moka",]$pop) + sum(travel.rates[ad2 == "Ureka",]$pop) + 
  sum(travel.rates[ad2 == "Riaba",]$pop)

View(travel.rates[ad2 == "Riaba"])
View(travel.rates[ad2 == "Baney"])
View(travel.rates[ad2 == "Malabo"])

# Look at a place inside Baney, what are the travel times to the different locations...

travel.model.data[areaId == 1815, ]
```

### Carlos also wants malaria importation rates

How do we calculate importations?  For a given area, we calculate a weighted sum over all possible destination regions that accounts for
  
  1. The fraction of susceptibles living in that area
  2. The force of infection at the target region
  3. The Time at Risk spent at the target region

We want to know the fraction of malaria infections that are acquired while traveling. What's omitted from this calculation is the fraction of malaria infections caused by force of infection at home, meaning we ignore the diagonal elements of $\psi_{i,j}$:

$$
\left( H_i - X_i \right) \sum_{j \ne i} \psi_{i,j} E_j
$$

Now we can use the travel matrix $\psi_{i,j}$ and FOI that we calculated to 
```{r}
names.for.matrix <- c(as.character(areaIds), "OffIsland", "Baney", "Luba", "Malabo", "Moka", "Riaba", "Ureka")
P.ij <- read.csv(file = "/Users/dtcitron/Documents/MASH/Bioko_Macro/FOI_Maps_With_TaR/TaR_matrix.csv", row.names = names.for.matrix, header = TRUE)
P.ij <- as.matrix(P.ij[, 2:202])
colnames(P.ij) <- names.for.matrix
#View(P.ij[, (194+1):(194+7)])

g <- r/(1-rho)*pfpr.input/(1-(1+rho*r/eta/(1-rho))*pfpr.input)
FOI <- ginv(P.ij) %*% g

# PfPR (infections) attributable to importations
(1-rho)*(1 - (1+rho*r/eta/(1-rho))*pfpr.input[1:194]) * ((P.ij - diag(diag(P.ij)))[, (194+1):(194+7)] %*% FOI[(194+1):(194+7)])[1:194]

# PfPR (infections) attributable to local transmission
# Note that the imported infections are only a few percent of the infections in these different places
# This may change if we adjust our FOI calculations based on those who had traveled vs. those who had not traveled...
(1-rho)*(1 - (1+rho*r/eta/(1-rho))*pfpr.input[1:194]) * P.ij[1:194, 1:194] %*% FOI[1:194]

# Output a data.table with columns: areaId, area population, area pfpr, local transmission, imported transmission
out <- data.table(areaId=areaIds, 
           area.pop=travel.model.data[Region == 1][, c("areaId", "pop")]$pop,
           pfpr=pfpr.input[1:194],
           local.infections= as.numeric((1-rho)*(1 - (1+rho*r/eta/(1-rho))*pfpr.input[1:194]) * P.ij[1:194, 1:194] %*% FOI[1:194]),
           imported.infections = (1-rho)*(1 - (1+rho*r/eta/(1-rho))*pfpr.input[1:194]) * ((P.ij - diag(diag(P.ij)))[, (194+1):(194+7)] %*% FOI[(194+1):(194+7)])[1:194],
           FOI = FOI[1:194]
           )
# One cursory check:
# These should all be zero
out$local.infections + out$imported.infections - out$pfpr/200

# Write out
fwrite(out, file = "/Users/dtcitron/Documents/MASH/Bioko_Macro/FOI_Maps_With_TaR/FOI_importations_local.csv")
```

